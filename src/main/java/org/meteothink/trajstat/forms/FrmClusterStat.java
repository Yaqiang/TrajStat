/* Copyright 2014 - Yaqiang Wang,
 * yaqiang.wang@gmail.com
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at
 * your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
 * General Public License for more details.
 */
package org.meteothink.trajstat.forms;

import java.awt.Cursor;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import org.meteoinfo.table.Field;
import org.meteoinfo.common.MIMath;
import org.meteoinfo.geo.layer.VectorLayer;
import org.meteoinfo.geo.legend.GroupNode;
import org.meteoinfo.geo.legend.LayerNode;
import org.meteoinfo.geo.plugin.IApplication;
import org.meteoinfo.ui.CheckTreeManager;
import org.meteoinfo.ui.CheckTreeSelectionModel;

/**
 *
 * @author Yaqiang Wang
 */
public class FrmClusterStat extends javax.swing.JDialog {

    private IApplication app;
    CheckTreeManager checkTreeManager;

    /**
     * Creates new form FrmClusterStat
     * @param parent
     * @param modal
     */
    public FrmClusterStat(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        initComponents();
        app = (IApplication) parent;

        // makes your tree as CheckTree
        DefaultMutableTreeNode layersTN = new DefaultMutableTreeNode("Trajectory", true);
        GroupNode gNode = app.getMapDocument().getActiveMapFrame().getGroupByName("Trajectory");
        for (LayerNode lNode : gNode.getLayers()) {
            layersTN.insert(new DefaultMutableTreeNode(lNode.getMapLayer()), 0);
        }
        DefaultTreeModel model = new DefaultTreeModel(layersTN);
        this.jTree_TrajLayers.setModel(model);
        checkTreeManager = new CheckTreeManager(this.jTree_TrajLayers);
        TreePath path = this.jTree_TrajLayers.getPathForRow(1);
        CheckTreeSelectionModel selModel = (CheckTreeSelectionModel) checkTreeManager.getSelectionModel();
        selModel.addTreeSelectionListener(new TreeSelectionListener() {
            @Override
            public void valueChanged(TreeSelectionEvent e) {
                onSelectionValueChanged(e);
            }
        });
        selModel.addSelectionPath(path);

        this.getFileds();
    }

    private void getFileds() {
        // to get the paths that were checked
        TreePath checkedPaths[] = checkTreeManager.getSelectionModel().getSelectionPaths();
        if (checkedPaths == null) {
            return;
        }

        VectorLayer layer = null;
        for (TreePath path : checkedPaths) {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            if (node.getChildCount() > 0) {
                DefaultMutableTreeNode cnode = (DefaultMutableTreeNode) node.getChildAt(0);
                layer = (VectorLayer) cnode.getUserObject();
            } else {
                layer = (VectorLayer) node.getUserObject();
                break;
            }
        }

        if (layer != null) {
            this.jComboBox_Field.removeAllItems();
            for (Field field : layer.getFields()) {
                if (field.isNumeric()) {
                    this.jComboBox_Field.addItem(field.getColumnName());
                }
            }
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jComboBox_Field = new javax.swing.JComboBox();
        jLabel2 = new javax.swing.JLabel();
        jTextField_Criterion = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jTextField_Missing = new javax.swing.JTextField();
        jButton_OK = new javax.swing.JButton();
        jButton_Cancel = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTree_TrajLayers = new javax.swing.JTree();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Cluster statistics");

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Setting"));

        jLabel1.setText("Field:");

        jComboBox_Field.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        jLabel2.setText("Criterion:");

        jTextField_Criterion.setText("0");

        jLabel3.setText("Missing:");

        jTextField_Missing.setText("0");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(14, 14, 14)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField_Missing))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField_Criterion))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jComboBox_Field, 0, 112, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jComboBox_Field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextField_Criterion, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jTextField_Missing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jButton_OK.setText("OK");
        jButton_OK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton_OKActionPerformed(evt);
            }
        });

        jButton_Cancel.setText("Cancel");
        jButton_Cancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton_CancelActionPerformed(evt);
            }
        });

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("colors");
        javax.swing.tree.DefaultMutableTreeNode treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("blue");
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("violet");
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("red");
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("yellow");
        treeNode1.add(treeNode2);
        jTree_TrajLayers.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        jScrollPane2.setViewportView(jTree_TrajLayers);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton_OK, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jButton_Cancel)
                        .addGap(22, 22, 22))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton_OK)
                            .addComponent(jButton_Cancel))
                        .addGap(0, 9, Short.MAX_VALUE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton_OKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton_OKActionPerformed
        // TODO add your handling code here:
        //Get selected layers
        TreePath checkedPaths[] = checkTreeManager.getSelectionModel().getSelectionPaths();
        if (checkedPaths == null) {
            JOptionPane.showMessageDialog(null, "There is no trajectory layer was selected!");
            return;
        }

        List<VectorLayer> layers = new ArrayList<>();
        for (TreePath path : checkedPaths) {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            if (node.getChildCount() > 0) {
                for (int i = 0; i < node.getChildCount(); i++) {
                    DefaultMutableTreeNode cnode = (DefaultMutableTreeNode) node.getChildAt(i);
                    layers.add((VectorLayer) cnode.getUserObject());
                }
            } else {
                layers.add((VectorLayer) node.getUserObject());
                break;
            }
        }        

        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        //Get the field
        String fieldName = this.jComboBox_Field.getSelectedItem().toString();

        //Get cluster number
        int i;
        int cNum = 1;
        int cFldIdx;
        for (VectorLayer layer : layers) {
            cFldIdx = layer.getFieldIdxByName("Cluster");
            if (cFldIdx == -1) {
                JOptionPane.showMessageDialog(null, "There is no Cluster field in " + layer.getLayerName() + "!");
                return;
            }
            for (i = 0; i < layer.getShapeNum(); i++) {
                int cn = Integer.parseInt(layer.getCellValue(cFldIdx, i).toString());
                if (cNum < cn) {
                    cNum = cn;
                }
            }
        }

        //Get pollution criterion
        double criterion = Double.parseDouble(this.jTextField_Criterion.getText());
        double missingValue = Double.parseDouble(this.jTextField_Missing.getText());

        //Statistic loop
        int aFldIdx;
        int clusterIdx;
        double aValue;
        double[] mValue = new double[cNum + 1];
        double[] mPValue = new double[cNum + 1];
        double[] stdev = new double[cNum + 1];
        double[] pStdev = new double[cNum + 1];
        int[] tNum = new int[cNum + 1];
        int[] ptNum = new int[cNum + 1];

        for (i = 0; i <= cNum; i++) {
            mValue[i] = 0.0;
            mPValue[i] = 0.0;
            tNum[i] = 0;
            ptNum[i] = 0;
            stdev[i] = 0.0;
            pStdev[i] = 0.0;
        }

        for (VectorLayer layer : layers) {
            aFldIdx = layer.getFieldIdxByName(fieldName);
            cFldIdx = layer.getFieldIdxByName("Cluster");
            for (i = 0; i < layer.getShapeNum(); i++) {
                aValue = Double.parseDouble(layer.getCellValue(aFldIdx, i).toString());
                clusterIdx = Integer.parseInt(layer.getCellValue(cFldIdx, i).toString());
                if (!MIMath.doubleEquals(aValue, missingValue)) {
                    mValue[clusterIdx - 1] += aValue;
                    tNum[clusterIdx - 1] += 1;
                    stdev[clusterIdx - 1] += Math.pow(aValue, 2);
                    mValue[cNum] += aValue;
                    tNum[cNum] += 1;
                    stdev[cNum] += Math.pow(aValue, 2);
                    if (aValue >= criterion) {
                        mPValue[clusterIdx - 1] += aValue;
                        ptNum[clusterIdx - 1] += 1;
                        pStdev[clusterIdx - 1] += Math.pow(aValue, 2);
                        mPValue[cNum] += aValue;
                        ptNum[cNum] += 1;
                        pStdev[cNum] += Math.pow(aValue, 2);
                    }
                }
            }
        }

        for (i = 0; i <= cNum; i++) {
            stdev[i] = Math.sqrt((tNum[i] * stdev[i] - Math.pow(mValue[i], 2)) / (tNum[i] * (tNum[i] - 1)));
            mValue[i] = mValue[i] / tNum[i];
            if (ptNum[i] > 1) {
                pStdev[i] = Math.sqrt((ptNum[i] * pStdev[i] - Math.pow(mPValue[i], 2)) / (ptNum[i] * (ptNum[i] - 1)));
                mPValue[i] = mPValue[i] / ptNum[i];
            } else {
                pStdev[i] = 0;
            }
        }

        //View result data
        Object[][] tData = new Object[cNum + 1][7];
        String[] colNames = new String[]{"Cluster", "Num", "Mean_Val", "Stdev", "P_Num", "P_Mean_Val", "P_Stdev"};
        for (i = 0; i <= cNum; i++) {
            if (i == cNum) {
                tData[i][0] = "All";
            } else {
                tData[i][0] = i + 1;
            }
            tData[i][1] = tNum[i];
            tData[i][2] = String.format("%1$.2f", mValue[i]);
            tData[i][3] = String.format("%1$.2f", stdev[i]);
            tData[i][4] = ptNum[i];
            tData[i][5] = String.format("%1$.2f", mPValue[i]);
            tData[i][6] = String.format("%1$.2f", pStdev[i]);
        }
        DefaultTableModel model = new DefaultTableModel(tData, colNames);
        FrmTable frmTable = new FrmTable((JFrame) app, false);
        frmTable.setTableModel(model);
        frmTable.setLocationRelativeTo((JFrame) app);
        frmTable.setVisible(true);

        this.setCursor(Cursor.getDefaultCursor());
    }//GEN-LAST:event_jButton_OKActionPerformed

    private void jButton_CancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton_CancelActionPerformed
        // TODO add your handling code here:
        this.dispose();
    }//GEN-LAST:event_jButton_CancelActionPerformed

    private void onSelectionValueChanged(TreeSelectionEvent evt) {
        this.getFileds();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FrmClusterStat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FrmClusterStat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FrmClusterStat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FrmClusterStat.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the dialog */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                FrmClusterStat dialog = new FrmClusterStat(new javax.swing.JFrame(), true);
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton_Cancel;
    private javax.swing.JButton jButton_OK;
    private javax.swing.JComboBox jComboBox_Field;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField jTextField_Criterion;
    private javax.swing.JTextField jTextField_Missing;
    private javax.swing.JTree jTree_TrajLayers;
    // End of variables declaration//GEN-END:variables
}
